#' Create a Local, CRAN-like Repository
#'
#' This function generates a local CRAN-like repository which can be
#' used to store and distribute \R packages.
#'
#' @param path Path to the local CRAN-like repository.
#' @param name The name to assign to the repository. Defaults to the
#'   directory name in which the reopsitory is created.
#' @param add Add this new repository to the current set of repositories?
#' @export
create_repo <- function(path, name = basename(path), add = TRUE) {

  if (file.exists(path))
    stop("Path '", path, "' is not empty; cannot create ",
         "repository at this location", call. = FALSE)

  if (name %in% names(getOption("repos")))
    stop("A repository named '", name, "' is already registered!")

  dir.create(path, recursive = TRUE)
  root <- normalize.path(path)

  ## Create the 'contrib' dirs

  # Create the 'src' dir and write PACKAGES
  srcContribDir <- file.path(root, "src", "contrib")
  dir.create(srcContribDir, recursive = TRUE)
  tools::write_PACKAGES(srcContribDir, type = "source")

  # Create the 'bin' dirs and write PACKAGES
  binContribDirs <- binContribDirs(root)
  lapply(binContribDirs, function(dirs) {
    lapply(dirs, function(dir) {
      dir.create(dir, recursive = TRUE)
      type <- if (grepl("/bin/windows/", dir))
        "win.binary"
      else if (grepl("/bin/macosx/", dir))
        "mac.binary"
      else
        "source"
      tools::write_PACKAGES(dir, type = type)
    })
  })

  message("Local CRAN repository '", name, "' created at: ",
          "\n- ", shQuote(normalize.path(path)))

  URI <- paste(filePrefix(), root, sep = "")
  names(URI) <- name

  if (add)
    options(repos = c(getOption("repos"), URI))

  URI
}

binContribDirs <- function(root, rVersions = NULL) {
  # Add a number of empty R-version folders by default, just
  # so that these versions of R don't fail when attempting to query
  # the PACKAGES file in the binary directory
  if (is.null(rVersions))
    rVersions <- c("2.15", "2.16", "3.0", "3.1", "3.2", "3.3")

  list(
    win.binary = file.path(root, "bin/windows/contrib", rVersions),
    mac.binary = file.path(root, "bin/macosx/contrib", rVersions),
    mac.binary.mavericks = file.path(root, "bin/macosx/mavericks/contrib", rVersions),
    mac.binary.leopard = file.path(root, "bin/macosx/leopard/contrib", rVersions)
  )
}

#' Upload a Package to a Local CRAN-like Repository
#'
#' @param package Path to a package tarball. The tarball should be
#'   created by \code{R CMD build}; alternatively, it can be the path
#'   to a folder containing the source code for a package (which
#'   will then be built with \code{R CMD build}) and then uploaded
#'   to the local repository.
#' @param to The name of the CRAN-like repository.
#' @param ... Optional arguments passed to \code{R CMD build}.
#' @export
upload_package <- function(package, to, ...) {

  # validation
  if (!file.exists(package))
    stop("no package named '", package, "'", call. = FALSE)

  if (is.directory(package) && !file.exists(file.path(package, "DESCRIPTION")))
    stop("directory '", package, "' exists but contains no DESCRIPTION file",
         call. = FALSE)

  if (!(is.directory(package)) && !(grepl("\\.tar\\.gz$", package)))
    stop("file '", package, "' exists but is not appropriately named; ",
         "uploadable package tarballs are generated by `R CMD build`",
         call. = FALSE)

  if (!is.string(to))
    stop("'to' should be a length-one character vector, naming ",
         "a repository available in 'getOption(\"repos\")'",
         call. = FALSE)

  repos <- getOption("repos")
  isNameOfRepo <- to %in% names(repos)
  isRepo <- to %in% repos

  if (!(isNameOfRepo || isRepo))
    stop("no repository '", to, "' available; ",
         "try adding a repository with 'packrat::add_repo()'",
         call. = FALSE)

  repo <- if (isNameOfRepo)
    repos[[to]]
  else
    to

  if (!grepl(reFilePrefix(), repo))
    stop("packages can only be uploaded to local CRAN-like repositories with ",
         "this version of packrat",
         call. = FALSE)

  # perform upload
  if (is.directory(package))
    uploadPackageSourceDir(package, repo, ...)
  else
    uploadPackageTarball(package, repo)
}

uploadPackageSourceDir <- function(package, repo, ...) {

  # create temporary directory for package
  randomString <- paste(sample(c(0:9, letters, LETTERS), 16, TRUE), collapse = "")
  dir <- file.path(tempdir(), paste(basename(package), randomString, sep = "-"))
  on.exit(unlink(dir, recursive = TRUE))

  success <- dir_copy(package, dir, pattern = "^[^\\.]")
  if (!all(success))
    stop("failed to copy package files to temporary directory")

  # Annotate the DESCRIPTION with the name of the repository we're
  # going to be uploading to
  descPath <- file.path(dir, "DESCRIPTION")
  setRepositoryField(descPath, repo)

  path <- build(dir, ...)
  if (!file.exists(path))
    stop("failed to build source package")

  contribUrl <- sub(reFilePrefix(), "", file.path(repo, "src", "contrib"))
  success <- file.copy(
    path,
    contribUrl
  )

  if (!success)
    stop("failed to copy built package to CRAN repo '", repo, "'")

  tools::write_PACKAGES(contribUrl, type = "source")
  message("Package '", basename(path), "' successfully uploaded.")
  file.path(contribUrl, basename(path))
}

uploadPackageTarball <- function(package, repo, ...) {

  # Annotate the package DESCRIPTION with the repository
  tmpTarballPath <- file.path(tempdir(), "packrat-tarball-upload")
  untar(package, exdir = tmpTarballPath)
  pkgName <- sub("_.*", "", basename(package))
  untarredPath <- file.path(tmpTarballPath, pkgName)
  setRepositoryField(
    file.path(untarredPath, "DESCRIPTION"),
    repo
  )

  owd <- getwd()
  setwd(tmpTarballPath)
  on.exit(setwd(owd), add = TRUE)

  success <- tar(basename(package), files = pkgName)
  if (success != 0)
    stop("Failed to re-tar package tarball")

  path <- normalize.path(basename(package))

  contribUrl <- sub(reFilePrefix(), "", file.path(repo, "src", "contrib"))
  if (!file.copy(path, contribUrl))
    stop("failed to upload package '", basename(package), "' to '", contribUrl, "'")

  tools::write_PACKAGES(contribUrl, type = "source")
  message("Package '", basename(path), "' successfully uploaded.")
  file.path(contribUrl, basename(path))
}

#' Add a Repository
#'
#' Add a repository to the set of currently available repositories. This is
#' effectively an easier-to-use wrapper over interacting with the
#' \code{"repos"} option, which is otherwise set with \code{options(repos = ...)}.
#'
#' @param ... Named arguments of the form \code{<repoName> = <pathToRepo>}
#' @param overwrite Boolean; overwrite if a repository with the given name
#'   already exists?
#'
#' @name repository-management
#' @rdname repository-management
#' @export
add_repos <- function(..., overwrite = FALSE) {

  dots <- list(...)
  if (any(!nzchar(names(dots))))
    stop("all argument to 'add_repos()' should be named")

  missing <- unlist(lapply(dots, function(x) {
    !file.exists(x)
  }))

  if (any(missing))
    stop("The following paths do not exist: \n- ",
         paste(shQuote(dots[missing]), collapse = "\n- "))

  oldRepos <- getOption("repos")
  if (!overwrite) {
    conflicts <- intersect(names(dots), names(oldRepos))
    if (length(conflicts)) {
      quoted <- paste(shQuote(conflicts), " (", oldRepos[conflicts], ")", sep = "")
      stop("The following repositories have already been set.\n",
           "Use 'overwrite = TRUE' to override these repository paths.\n- ",
           paste(quoted, collapse = "\n- "))
    }
  }


  # TODO: support non-local (ie non-file based) repos
  paths <- normalizePath(unlist(dots), winslash = "/", mustWork = TRUE)
  URIs <- paste(filePrefix(), paths, sep = "")

  newRepos <- URIs
  names(newRepos) <- names(dots)

  repos <- c(oldRepos, newRepos)
  options(repos = repos)
  invisible(repos)
}

#' @name repository-management
#' @rdname repository-management
#' @export
set_repos <- function(...) {
  add_repos(..., overwrite = TRUE)
}

setRepositoryField <- function(descPath, repo) {
  contents <- readLines(descPath)
  repoIdx <- grep("^Repository:", contents)
  repoLine <- paste("Repository:", repo)
  if (length(repoIdx))
    contents[[repoIdx]] <- repoLine
  else
    contents <- c(contents, repoLine)
  cat(contents, file = descPath, sep = "\n")
}
